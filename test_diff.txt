diff --git a/qiskit/transpiler/passes/utils/remove_final_measurements.py b/qiskit/transpiler/passes/utils/remove_final_measurements.py
index a2c412f734ec..98cc30b85cf0 100644
--- a/qiskit/transpiler/passes/utils/remove_final_measurements.py
+++ b/qiskit/transpiler/passes/utils/remove_final_measurements.py
@@ -46,6 +46,15 @@ def calc_final_ops(dag: DAGCircuit, final_op_names: set[str]) -> list[DAGOpNode]
                 # Record the encounter, and bail!
                 barrier_encounters_remaining[node] -= 1
                 continue
+
+        if node.op.name == "measure":
+            # Skip if any classical successor is a control flow operation
+            if any(
+                isinstance(successor, DAGOpNode) and successor.is_control_flow()
+                for successor in dag.classical_successors(node)
+            ):
+                continue
+
         if node.name in final_op_names:
             # Current node is either a measure, or a barrier with all final op children.
             final_ops.append(node)
@@ -60,7 +69,9 @@ class RemoveFinalMeasurements(TransformationPass):
     This pass removes final barriers and final measurements, as well as all
     unused classical registers and bits they are connected to.
     Measurements and barriers are considered final if they are
-    followed by no other operations (aside from other measurements or barriers.)
+    followed by no other operations (aside from other measurements or barriers).
+    Furthermore, a measurement is not considered final if its classical output
+    is used to condition a control flow gate.
 
     Classical registers are removed iff they reference at least one bit
     that has become unused by the circuit as a result of the operation, and all
diff --git a/releasenotes/notes/fix-remove_final_measurements-pass-c01e16946bd039b5.yaml b/releasenotes/notes/fix-remove_final_measurements-pass-c01e16946bd039b5.yaml
new file mode 100644
index 000000000000..5d9a2bb5701f
--- /dev/null
+++ b/releasenotes/notes/fix-remove_final_measurements-pass-c01e16946bd039b5.yaml
@@ -0,0 +1,5 @@
+---
+fixes:
+  - |
+    Fixed an issue where measurements used in control flow operations were incorrectly removed by the `RemoveFinalMeasurements` pass.
+    Refer to `#14319 <https://github.com/Qiskit/qiskit/issues/14319>`for more details.
\ No newline at end of file
diff --git a/test/python/transpiler/test_remove_final_measurements.py b/test/python/transpiler/test_remove_final_measurements.py
index ee5fe0cdb1a7..c024e92c3458 100644
--- a/test/python/transpiler/test_remove_final_measurements.py
+++ b/test/python/transpiler/test_remove_final_measurements.py
@@ -304,6 +304,144 @@ def test_calc_final_ops(self):
         final_barriers = calc_final_ops(circuit_to_dag(qc), {"barrier"})
         self.assertEqual(final_barriers, [])
 
+    def test_measurements_with_control_flow_succesors(self):
+        """Final measurements with control flow successors should not be considered final."""
+
+        def build_if_circuit():
+            q0 = QuantumRegister(3, "q0")
+            c0 = ClassicalRegister(2, "c0")
+            qc = QuantumCircuit(q0, c0)
+
+            #        ┌───┐┌─┐
+            #  q0_0: ┤ H ├┤M├──────────────────────────
+            #        ├───┤└╥┘┌─┐
+            #  q0_1: ┤ X ├─╫─┤M├───────────────────────
+            #        └───┘ ║ └╥┘┌────── ┌───┐ ───────┐
+            #  q0_2: ──────╫──╫─┤ If-0  ┤ X ├  End-0 ├─
+            #              ║  ║ └──╥─── └───┘ ───────┘
+            #              ║  ║ ┌──╨──┐
+            #  c0: 2/══════╩══╩═╡ 0x3 ╞════════════════
+            #              0  1 └─────┘
+
+            qc.h(0)
+            qc.x(1)
+            qc.measure(q0[0], c0[0])
+            qc.measure(q0[1], c0[1])
+            with qc.if_test((c0, 0b11)):
+                qc.x(q0[2])
+            return qc
+
+        def build_while_circuit():
+            q0 = QuantumRegister(3, "q0")
+            c0 = ClassicalRegister(2, "c0")
+            qc = QuantumCircuit(q0, c0)
+
+            #       ┌───┐┌─┐
+            # q0_0: ┤ H ├┤M├─────────────────────────────
+            #       ├───┤└╥┘┌─┐
+            # q0_1: ┤ X ├─╫─┤M├──────────────────────────
+            #       └───┘ ║ └╥┘┌───────── ┌───┐ ───────┐
+            # q0_2: ──────╫──╫─┤ While-0  ┤ X ├  End-0 ├─
+            #             ║  ║ └────╥──── └───┘ ───────┘
+            #             ║  ║   ┌──╨──┐
+            # c0: 2/══════╩══╩═══╡ 0x3 ╞═════════════════
+
+            qc.h(0)
+            qc.x(1)
+            qc.measure(q0[0], c0[0])
+            qc.measure(q0[1], c0[1])
+            with qc.while_loop((c0, 0b11)):
+                qc.x(q0[2])
+            return qc
+
+        def build_switch_circuit():
+            q0 = QuantumRegister(3, "q0")
+            c0 = ClassicalRegister(2, "c0")
+            qc = QuantumCircuit(q0, c0)
+
+            #       ┌───┐┌─┐
+            # q0_0: ┤ H ├┤M├───────────────────────────────────────────────────────────────
+            #       ├───┤└╥┘┌─┐
+            # q0_1: ┤ X ├─╫─┤M├────────────────────────────────────────────────────────────
+            #       └───┘ ║ └╥┘┌────────── ┌──────────── ┌───┐┌──────────── ┌───┐ ───────┐
+            # q0_2: ──────╫──╫─┤ Switch-0  ┤ Case-0 (0)  ┤ X ├┤ Case-0 (3)  ┤ Z ├  End-0 ├─
+            #             ║  ║ └────╥───── └──────────── └───┘└──────────── └───┘ ───────┘
+            #             ║  ║   ┌──╨──┐
+            # c0: 2/══════╩══╩═══╡ 0x3 ╞═══════════════════════════════════════════════════
+            # .            0  1   └─────┘
+
+            qc.h(0)
+            qc.x(1)
+            qc.measure(q0[0], c0[0])
+            qc.measure(q0[1], c0[1])
+            with qc.switch(c0) as case:
+                with case(0):
+                    qc.x(2)
+                with case(3):
+                    qc.z(2)
+
+            return qc
+
+        for desc, qc in [
+            ("if", build_if_circuit()),
+            ("while", build_while_circuit()),
+            ("switch", build_switch_circuit()),
+        ]:
+            with self.subTest(control_flow=desc):
+                dag = circuit_to_dag(qc)
+                final_ops = calc_final_ops(dag=dag, final_op_names={"measure", "barrier"})
+                self.assertEqual(final_ops, [], f"Failed for control flow: {desc}")
+
+    def test_measurements_with_some_control_flow_successor(self):
+        """Test circuit with some measurements having control flow successors"""
+
+        q0 = QuantumRegister(3, "q0")
+        c0 = ClassicalRegister(1, "c0")
+        c1 = ClassicalRegister(1, "c1")
+
+        #       ┌───┐┌─┐
+        # q0_0: ┤ H ├┤M├──────────────────────────
+        #       ├───┤└╥┘┌─┐
+        # q0_1: ┤ X ├─╫─┤M├───────────────────────
+        #       └───┘ ║ └╥┘┌────── ┌───┐ ───────┐
+        # q0_2: ──────╫──╫─┤ If-0  ┤ X ├  End-0 ├─
+        #             ║  ║ └──╥─── └───┘ ───────┘
+        #             ║  ║ ┌──╨──┐
+        # c0: 1/══════╩══╬═╡ 0x1 ╞════════════════
+        #             0  ║ └─────┘
+        # c1: 1/═════════╩════════════════════════
+        #                0
+
+        qc = QuantumCircuit(q0, c0, c1)
+        qc.h(0)
+        qc.x(1)
+        qc.measure(q0[0], c0[0])
+        qc.measure(q0[1], c1[0])
+        with qc.if_test((c0, 0b1)):
+            qc.x(q0[2])
+        dag = circuit_to_dag(qc)
+        final_ops = calc_final_ops(dag=dag, final_op_names={"measure", "barrier"})
+        self.assertEqual(len(final_ops), 1)
+
+    def test_mid_circuit_measures_with_control_flow_sucessors(self):
+        """Test circuit having mid circuit measurement with control flow successors."""
+
+        q0 = QuantumRegister(3, "q0")
+        c0 = ClassicalRegister(1, "c0")
+        c1 = ClassicalRegister(1, "c1")
+
+        qc = QuantumCircuit(q0, c0, c1)
+        qc.h(0)
+        qc.x(1)
+        qc.measure(q0[0], c0[0])
+        qc.measure(q0[1], c1[0])
+        with qc.if_test((c0, 0b1)):
+            qc.x(q0[2])
+        qc.measure_all()
+        dag = circuit_to_dag(qc)
+        final_ops = calc_final_ops(dag=dag, final_op_names={"measure", "barrier"})
+        self.assertEqual(len(final_ops), 5)
+
 
 if __name__ == "__main__":
     unittest.main()